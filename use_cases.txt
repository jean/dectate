
* Different types of actions need to group together so they
  conflict/override. Currently uses group_key method. (Stick to this,
  as class is needed to sort actions by dependency)

* An action has an identifier for conflicts and overrides. Prefixed by
  group key so we don't need to distinguish between actions in
  different groups. (works)

* Extra discriminator list to make more conflicts happen. (works)

* Generate sub-actions instead of performing things directly. This is
  done in prepare right now. (works)

* Directive abbreviations. (works)

* Deal properly with an action or composite that has no __init__. Error.

* Ensure that morepath directives get registered before we start using them
  in imports.

* Abbreviated directives should have correct frame info for error
  reporting. (done)

* Do checks on input parameters depending on what object is being
  decorated (class versus function). Done in prepare, such as for path
  directive. Should now move it into perform and raise errors if
  things are wrong. Check on error reporting. (done)

* Dependencies between actions. (done)

* Directives have a name. is it used in logging?

* Directives have documentation that shows up in the sphinx docs

* Directive logging.

* Subclasses of App can have new directives through the directive
  directive (works)

* We have some use cases where we'd like to execute some code after
  all directives of a particular kind are done executing. This way we
  could initialize the predicates for all external predicates
  functions, for instance.

* Prepare now only works one level deep: you can't implement a
  directive as multiple actions which then in turn are actually other
  actions. This has been fixed with Composite actions (done)

* Sometimes during prepare it'd be useful to have access to the registry.

* Apps could have multiple independent registries (or at least
  registries APIs; many will build on the reg registry). Perhaps
  actions can somehow declare which registry APIs they concern
  themselves with. This way we could avoid mixing a lot of registry
  mixins into a larger registry. (this now works)

* if multiple directives declare different classes for the configuration
  registry that should be an error.

* There's another use case to apply the action to the app, not to
  app.registry directly: the logging functionality needs this
  information. I've worked around it now with a hack that sets up the
  app as an attribute on the registry after the fact...

* Not use Venusian: a directive should register with the configuration
  system (or better: the App) immediately upon import as it's easier to
  explain. (done)

* Support configuration isolation: re-run configuration multiple times.

* Determine that two toplevel directives are actually the same one by
  looking at line number information.

* Have line number information for error reporting. (done)

* Support querying the registration database to see what directives
  have been applied. Should this be the registration data or should it
  be based around directives?

* Support logging.

* Refuse to support classmethod & staticmethod?

* The config object should get the configurables explicitly. Or apps?
  And then allow a commit.

* there's also an implicit list of configurables kept globally that can
  be reset.

* rename to something else as Confidant as now on PyPI.

* separate "configurations" object from configurable.

confide

decadent

decalogue decalog; but log is not used.

gure

decafig

confey

dectate
